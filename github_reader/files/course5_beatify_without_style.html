<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   05 | 一不小心就死锁了，怎么办？
  </title>
 </head>
 <body>
  <div id="app">
   <div class="article" data-v-87ffcada="">
    <div class="main main-app" data-v-87ffcada="">
     <div class="breadcrumb breadcrumb pd" data-v-87ffcada="">
     </div>
     <h1 class="article-title pd" data-v-87ffcada="">
      05 | 一不小心就死锁了，怎么办？
     </h1>
     <div class="article-info pd" data-v-87ffcada="">
      <span data-v-87ffcada="">
       2019-03-09
      </span>
      <span data-v-87ffcada="">
       王宝令
      </span>
     </div>
     <div class="article-content typo common-content pd" data-v-87ffcada="">
      <img data-v-87ffcada="" src="picture"/>
      <center>
       <a href="https://static001.geekbang.org/resource/image/db/12/db1e9a02a6f3a46138d3615ab1e96712.jpg">
        图片链接
       </a>
      </center>
      <div class="" data-v-87ffcada="" id="article-content">
       <div class="text">
        <p>
         在上一篇文章中，我们用Account.class作为互斥锁，来解决银行业务里面的转账问题，虽然这个方案不存在并发问题，但是所有账户的转账操作都是串行的，例如账户A 转账户B、账户C 转账户D这两个转账操作现实世界里是可以并行的，但是在这个方案里却被串行化了，这样的话，性能太差。
        </p>
        <p>
         试想互联网支付盛行的当下，8亿网民每人每天一笔交易，每天就是8亿笔交易；每笔交易都对应着一次转账操作，8亿笔交易就是8亿次转账操作，也就是说平均到每秒就是近1万次转账操作，若所有的转账操作都串行，性能完全不能接受。
        </p>
        <p>
         那下面我们就尝试着把性能提升一下。
        </p>
        <h2>
         向现实世界要答案
        </h2>
        <p>
         现实世界里，账户转账操作是支持并发的，而且绝对是真正的并行，银行所有的窗口都可以做转账操作。只要我们能仿照现实世界做转账操作，串行的问题就解决了。
        </p>
        <p>
         我们试想在古代，没有信息化，账户的存在形式真的就是一个账本，而且每个账户都有一个账本，这些账本都统一存放在文件架上。银行柜员在给我们做转账时，要去文件架上把转出账本和转入账本都拿到手，然后做转账。这个柜员在拿账本的时候可能遇到以下三种情况：
        </p>
        <ol>
         <li>
          文件架上恰好有转出账本和转入账本，那就同时拿走；
         </li>
         <li>
          如果文件架上只有转出账本和转入账本之一，那这个柜员就先把文件架上有的账本拿到手，同时等着其他柜员把另外一个账本送回来；
         </li>
         <li>
          转出账本和转入账本都没有，那这个柜员就等着两个账本都被送回来。
         </li>
        </ol>
        <!-- [[[read_end]]] -->
        <p>
         上面这个过程在编程的世界里怎么实现呢？其实用两把锁就实现了，转出账本一把，转入账本另一把。在transfer()方法内部，我们首先尝试锁定转出账户this（先把转出账本拿到手），然后尝试锁定转入账户target（再把转入账本拿到手），只有当两者都成功时，才执行转账操作。这个逻辑可以图形化为下图这个样子。
        </p>
        <p>
         <img alt="" src="picture"/>
        </p>
        <center>
         <a href="https://static001.geekbang.org/resource/image/cb/55/cb18e672732ab76fc61d60bdf66bf855.png">
          图片链接
         </a>
        </center>
        <center>
         <span class="reference">
          两个转账操作并行示意图
         </span>
        </center>
        <p>
         而至于详细的代码实现，如下所示。经过这样的优化后，账户A 转账户B和账户C 转账户D这两个转账操作就可以并行了。
        </p>
        <pre><code>class Account {
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 锁定转出账户
    synchronized(this) {              
      // 锁定转入账户
      synchronized(target) {           
        if (this.balance &gt; amt) {
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
</code></pre>
        <h2>
         没有免费的午餐
        </h2>
        <p>
         上面的实现看上去很完美，并且也算是将锁用得出神入化了。相对于用Account.class作为互斥锁，锁定的范围太大，而我们锁定两个账户范围就小多了，这样的锁，上一章我们介绍过，叫
         <strong>
          细粒度锁
         </strong>
         。
         <strong>
          使用细粒度锁可以提高并行度，是性能优化的一个重要手段
         </strong>
         。
        </p>
        <p>
         这个时候可能你已经开始警觉了，使用细粒度锁这么简单，有这样的好事，是不是也要付出点什么代价啊？编写并发程序就需要这样时时刻刻保持谨慎。
        </p>
        <p>
         <strong>
          的确，使用细粒度锁是有代价的，这个代价就是可能会导致死锁。
         </strong>
        </p>
        <p>
         在详细介绍死锁之前，我们先看看现实世界里的一种特殊场景。如果有客户找柜员张三做个转账业务：账户A 转账户B 100元，此时另一个客户找柜员李四也做个转账业务：账户B 转账户A 100 元，于是张三和李四同时都去文件架上拿账本，这时候有可能凑巧张三拿到了账本A，李四拿到了账本B。张三拿到账本A后就等着账本B（账本B已经被李四拿走），而李四拿到账本B后就等着账本A（账本A已经被张三拿走），他们要等多久呢？他们会永远等待下去…因为张三不会把账本A送回去，李四也不会把账本B送回去。我们姑且称为死等吧。
        </p>
        <p>
         <img alt="" src="picture"/>
        </p>
        <center>
         <a href="https://static001.geekbang.org/resource/image/f2/88/f293dc0d92b7c8255bd0bc790fc2a088.png">
          图片链接
         </a>
        </center>
        <center>
         <span class="reference">
          转账业务中的“死等”
         </span>
        </center>
        <p>
         现实世界里的死等，就是编程领域的死锁了。
         <strong>
          死锁
         </strong>
         的一个比较专业的定义是：
         <strong>
          一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象
         </strong>
         。
        </p>
        <p>
         上面转账的代码是怎么发生死锁的呢？我们假设线程T1执行账户A转账户B的操作，账户A.transfer(账户B)；同时线程T2执行账户B转账户A的操作，账户B.transfer(账户A)。当T1和T2同时执行完①处的代码时，T1获得了账户A的锁（对于T1，this是账户A），而T2获得了账户B的锁（对于T2，this是账户B）。之后T1和T2在执行②处的代码时，T1试图获取账户B的锁时，发现账户B已经被锁定（被T2锁定），所以T1开始等待；T2则试图获取账户A的锁时，发现账户A已经被锁定（被T1锁定），所以T2也开始等待。于是T1和T2会无期限地等待下去，也就是我们所说的死锁了。
        </p>
        <pre><code>class Account {
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 锁定转出账户
    synchronized(this){     ①
      // 锁定转入账户
      synchronized(target){ ②
        if (this.balance &gt; amt) {
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
</code></pre>
        <p>
         关于这种现象，我们还可以借助资源分配图来可视化锁的占用情况（资源分配图是个有向图，它可以描述资源和线程的状态）。其中，资源用方形节点表示，线程用圆形节点表示；资源中的点指向线程的边表示线程已经获得该资源，线程指向资源的边则表示线程请求资源，但尚未得到。转账发生死锁时的资源分配图就如下图所示，一个“各据山头死等”的尴尬局面。
        </p>
        <p>
         <img alt="" src="picture"/>
        </p>
        <center>
         <a href="https://static001.geekbang.org/resource/image/82/1c/829d69c7d32c3ad1b89d89fc56017d1c.png">
          图片链接
         </a>
        </center>
        <center>
         <span class="reference">
          转账发生死锁时的资源分配图
         </span>
        </center>
        <h2>
         如何预防死锁
        </h2>
        <p>
         并发程序一旦死锁，一般没有特别好的方法，很多时候我们只能重启应用。因此，解决死锁问题最好的办法还是规避死锁。
        </p>
        <p>
         那如何避免死锁呢？要避免死锁就需要分析死锁发生的条件，有个叫Coffman的牛人早就总结过了，只有以下这四个条件都发生时才会出现死锁：
        </p>
        <blockquote>
        </blockquote>
        <ol>
         <li>
          互斥，共享资源X和Y只能被一个线程占用；
         </li>
         <li>
          占有且等待，线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X；
         </li>
         <li>
          不可抢占，其他线程不能强行抢占线程T1占有的资源；
         </li>
         <li>
          循环等待，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待。
         </li>
        </ol>
        <p>
         反过来分析，
         <strong>
          也就是说只要我们破坏其中一个，就可以成功避免死锁的发生
         </strong>
         。
        </p>
        <p>
         其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？
        </p>
        <ol>
         <li>
          对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。
         </li>
         <li>
          对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。
         </li>
         <li>
          对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。
         </li>
        </ol>
        <p>
         我们已经从理论上解决了如何预防死锁，那具体如何体现在代码上呢？下面我们就来尝试用代码实践一下这些理论。
        </p>
        <h3>
         1. 破坏占用且等待条件
        </h3>
        <p>
         从理论上讲，要破坏这个条件，可以一次性申请所有资源。在现实世界里，就拿前面我们提到的转账操作来讲，它需要的资源有两个，一个是转出账户，另一个是转入账户，当这两个账户同时被申请时，我们该怎么解决这个问题呢？
        </p>
        <p>
         可以增加一个账本管理员，然后只允许账本管理员从文件架上拿账本，也就是说柜员不能直接在文件架上拿账本，必须通过账本管理员才能拿到想要的账本。例如，张三同时申请账本A和B，账本管理员如果发现文件架上只有账本A，这个时候账本管理员是不会把账本A拿下来给张三的，只有账本A和B都在的时候才会给张三。这样就保证了“一次性申请所有资源”。
        </p>
        <p>
         <img alt="" src="picture"/>
        </p>
        <center>
         <a href="https://static001.geekbang.org/resource/image/27/db/273af8c2ee60bd659f18673d2af005db.png">
          图片链接
         </a>
        </center>
        <center>
         <span class="reference">
          通过账本管理员拿账本
         </span>
        </center>
        <p>
         对应到编程领域，“同时申请”这个操作是一个临界区，我们也需要一个角色（Java里面的类）来管理这个临界区，我们就把这个角色定为Allocator。它有两个重要功能，分别是：同时申请资源apply()和同时释放资源free()。账户Account 类里面持有一个Allocator的单例（必须是单例，只能由一个人来分配资源）。当账户Account在执行转账操作的时候，首先向Allocator同时申请转出账户和转入账户这两个资源，成功后再锁定这两个资源；当转账操作执行完，释放锁之后，我们需通知Allocator同时释放转出账户和转入账户这两个资源。具体的代码实现如下。
        </p>
        <pre><code>class Allocator {
  private List&lt;Object&gt; als =
    new ArrayList&lt;&gt;();
  // 一次性申请所有资源
  synchronized boolean apply(
    Object from, Object to){
    if(als.contains(from) ||
         als.contains(to)){
      return false;  
    } else {
      als.add(from);
      als.add(to);  
    }
    return true;
  }
  // 归还资源
  synchronized void free(
    Object from, Object to){
    als.remove(from);
    als.remove(to);
  }
}

class Account {
  // actr应该为单例
  private Allocator actr;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 一次性申请转出账户和转入账户，直到成功
    while(!actr.apply(this, target))
      ；
    try{
      // 锁定转出账户
      synchronized(this){              
        // 锁定转入账户
        synchronized(target){           
          if (this.balance &gt; amt){
            this.balance -= amt;
            target.balance += amt;
          }
        }
      }
    } finally {
      actr.free(this, target)
    }
  } 
}
</code></pre>
        <h3>
         2. 破坏不可抢占条件
        </h3>
        <p>
         破坏不可抢占条件看上去很简单，核心是要能够主动释放它占有的资源，这一点synchronized是做不到的。原因是synchronized申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。
        </p>
        <p>
         你可能会质疑，“Java作为排行榜第一的语言，这都解决不了？”你的怀疑很有道理，Java在语言层次确实没有解决这个问题，不过在SDK层面还是解决了的，java.util.concurrent这个包下面提供的Lock是可以轻松解决这个问题的。关于这个话题，咱们后面会详细讲。
        </p>
        <h3>
         3. 破坏循环等待条件
        </h3>
        <p>
         破坏这个条件，需要对资源进行排序，然后按序申请资源。这个实现非常简单，我们假设每个账户都有不同的属性 id，这个 id 可以作为排序字段，申请的时候，我们可以按照从小到大的顺序来申请。比如下面代码中，①~⑥处的代码对转出账户（this）和转入账户（target）排序，然后按照序号从小到大的顺序锁定账户。这样就不存在“循环”等待了。
        </p>
        <pre><code>class Account {
  private int id;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    Account left = this        ①
    Account right = target;    ②
    if (this.id &gt; target.id) { ③
      left = target;           ④
      right = this;            ⑤
    }                          ⑥
    // 锁定序号小的账户
    synchronized(left){
      // 锁定序号大的账户
      synchronized(right){ 
        if (this.balance &gt; amt){
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
</code></pre>
        <h2>
         总结
        </h2>
        <p>
         当我们在编程世界里遇到问题时，应不局限于当下，可以换个思路，向现实世界要答案，
         <strong>
          利用现实世界的模型来构思解决方案
         </strong>
         ，这样往往能够让我们的方案更容易理解，也更能够看清楚问题的本质。
        </p>
        <p>
         但是现实世界的模型有些细节往往会被我们忽视。因为在现实世界里，人太智能了，以致有些细节实在是显得太不重要了。在转账的模型中，我们为什么会忽视死锁问题呢？原因主要是在现实世界，我们会交流，并且会很智能地交流。而编程世界里，两个线程是不会智能地交流的。所以在利用现实模型建模的时候，我们还要仔细对比现实世界和编程世界里的各角色之间的差异。
        </p>
        <p>
         我们今天这一篇文章主要讲了
         <strong>
          用细粒度锁来锁定多个资源时，要注意死锁的问题
         </strong>
         。这个就需要你能把它强化为一个思维定势，遇到这种场景，马上想到可能存在死锁问题。当你知道风险之后，才有机会谈如何预防和避免，因此，
         <strong>
          识别出风险很重要
         </strong>
         。
        </p>
        <p>
         预防死锁主要是破坏三个条件中的一个，有了这个思路后，实现就简单了。但仍需注意的是，有时候预防死锁成本也是很高的。例如上面转账那个例子，我们破坏占用且等待条件的成本就比破坏循环等待条件的成本高，破坏占用且等待条件，我们也是锁了所有的账户，而且还是用了死循环
         <code>
          while(!actr.apply(this, target));
         </code>
         方法，不过好在apply()这个方法基本不耗时。 在转账这个例子中，破坏循环等待条件就是成本最低的一个方案。
        </p>
        <p>
         所以我们在选择具体方案的时候，还需要
         <strong>
          评估一下操作成本，从中选择一个成本最低的方案
         </strong>
         。
        </p>
        <h2>
         课后思考
        </h2>
        <p>
         我们上面提到：破坏占用且等待条件，我们也是锁了所有的账户，而且还是用了死循环
         <code>
          while(!actr.apply(this, target));
         </code>
         这个方法，那它比synchronized(Account.class)有没有性能优势呢？
        </p>
        <p>
         欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。
        </p>
        <p>
         <img alt="" src="picture"/>
        </p>
        <center>
         <a href="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg">
          图片链接
         </a>
        </center>
       </div>
      </div>
     </div>
     <!-- -->
     <!-- -->
    </div>
    <div class="article-comments pd" data-v-87ffcada="">
     <h2 data-v-87ffcada="">
      <span data-v-87ffcada="">
       精选留言
      </span>
     </h2>
     <ul data-v-87ffcada="">
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/0f/96/63/fdbf75eb.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          捞鱼的搬砖奇
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            28
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         synchronized(Account.class) 锁了Account类相关的所有操作。相当于文中说的包场了，只要与Account有关联，通通需要等待当前线程操作完成。while死循环的方式只锁定了当前操作的两个相关的对象。两种影响到的范围不同。
        </div>
        <span class="time">
         2019-03-09
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          还真是这样啊！
          <br/>
         </p>
         <p class="reply-time">
          2019-03-09
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/0f/48/bd/6c7d4230.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          Tony Du
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            23
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         while循环是不是应该有个timeout，避免一直阻塞下去？
        </div>
        <span class="time">
         2019-03-09
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          你考虑的很周到！👍
          <br/>
          加超时在实际项目中非常重要！
         </p>
         <p class="reply-time">
          2019-03-09
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/10/10/bb/fcca0b42.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          DemonLee
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            17
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         while(actr.apply(this, target)); --&gt; while(!actr.apply(this, target));
         <br/>
         我感觉应该是这样，老师，我理解错了？
        </div>
        <span class="time">
         2019-03-09
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          你发现了个大bug!感谢感谢！！！我这就修改一下啊
          <br/>
         </p>
         <p class="reply-time">
          2019-03-09
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/13/3d/51/9723276c.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          邋遢的流浪剑客
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            11
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         思考题的话希望老师能够过后给出一个比较标准的答案，毕竟大家的留言中说法各不相同很难去判断答案的对错
        </div>
        <span class="time">
         2019-03-09
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          这一部分的最后一章，要不就给答案吧
          <br/>
         </p>
         <p class="reply-time">
          2019-03-09
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/12/cb/61/b62d8a3b.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          张立华
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            9
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         之前遇到死锁，我就是用资源id的从小到大的顺序去申请锁解决的
        </div>
        <span class="time">
         2019-03-12
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          这个方案最简单
          <br/>
         </p>
         <p class="reply-time">
          2019-03-12
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          别皱眉
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            8
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         @阿官 我来回答下你的问题
         <br/>
         <br/>
         以下是阿官的问题
         <br/>
         -------------------------------------------------------
         <br/>
         老师，在破坏占用且等待的案例中，为何申请完两个账户的资源后还需要再分别锁定this和target账户呢？
         <br/>
         -------------------------------------------------------
         <br/>
         因为还存在其他业务啊 比如客户取款
         <br/>
         这个时候也是对全局变量balance做操作
         <br/>
         如果不加锁 并发情况下会出问题
         <br/>
         <br/>
         老师你看我说的对吗😄😄
        </div>
        <span class="time">
         2019-03-14
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          你说到我心里了😃😃😃
          <br/>
         </p>
         <p class="reply-time">
          2019-03-14
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/11/fb/87/9c2dc94f.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          几字凉了秋丶
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            8
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         老师，请问一下，在实际的开发中，account对象应该是从数据库中查询出来的吧，假如A转B，C转B一起执行，那B的account对象如何保证是同一个对象，不太理解。。。
        </div>
        <span class="time">
         2019-03-10
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          实际开发中都是用数据库事务+乐观锁的方式解决的。这个就是个例子，为了说明死锁是怎么回事，以及死锁问题怎么解决。
         </p>
         <p class="reply-time">
          2019-03-10
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/11/34/cd/4e2cd598.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          Howie
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            7
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         while 循环就是一个自旋锁机制吧，自旋锁的话要关注它的循环时间，不能一直循环下去，不然会浪费 cpu 资源。
        </div>
        <span class="time">
         2019-03-09
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          自旋锁在JVM里是一种特殊的锁机制，自诩不会阻塞线程的。咱们这个其实还是会阻塞线程的。不过原理都一样，你这样理解也没问题。
         </p>
         <p class="reply-time">
          2019-03-09
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/13/18/f6/2ff7bc7a.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          轻歌赋
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            6
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         存在性能差距，虽然申请的时候加锁导致单线程访问，但是hash判断和赋值时间复杂度低，而在锁中执行业务代码时间长很多。
         <br/>
         申请的时候单线程，但是执行的时候就可以多线程了，这里性能提升比较明显
         <br/>
         <br/>
         想问问老师，如何判断多线程的阻塞导致的问题呢？有什么工具吗
        </div>
        <span class="time">
         2019-03-09
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          可以用top命令查看Java线程的cpu利用率，用jstack来dump线程。开发环境可以用 java visualvm查看线程执行情况
         </p>
         <p class="reply-time">
          2019-03-09
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          aguan(^･ｪ･^)
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            4
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         老师，在破坏占用且等待的案例中，为何申请完两个账户的资源后还需要再分别锁定this和target账户呢？
        </div>
        <span class="time">
         2019-03-14
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          为了保险而已，单纯这个例子是不需要的，如果还有取款操作就需要了
          <br/>
         </p>
         <p class="reply-time">
          2019-03-14
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/0f/4e/60/be4992fd.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          gogo
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            4
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         看了老师的讲解学到了很多，联想了下实际转账业务，应该是数据库来实现的，假如有账户表account，利用mysql的悲观锁select ...for update对a，b两条数据锁定，这时也有可能发生死锁，按照您讲到的第三种破坏循环等待的方式，按照id的大小顺序依次锁定。我这样理解的对吗？
        </div>
        <span class="time">
         2019-03-10
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          是的，就是id的次序。
         </p>
         <p class="reply-time">
          2019-03-10
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBywibUar2Q8TmCy6ZrNQk9qia7sQgosBYInmygZI118vzrWu4CfUQnbOefvP82c8Inhb6xVqymhvYw/132">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          winter
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            4
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         我的想法是，如果Account对象中只有转账业务的话，while(actr.apply(this, target)和对象锁synchronized(Account.class)的性能优势几乎看不出来，synchronized(Account.class)的性能甚至更差；但是如果Account对象中如果还有其它业务，比如查看余额等功能也加了synchronized(Account.class)修饰，那么把单独的转账业务剥离出来，性能的提升可能就比较明显了。
         <br/>
        </div>
        <span class="time">
         2019-03-09
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          是的，有时候性能更差，毕竟要synchronized三次。但是有些场景会更好，例如转账操作很慢，而apply很快，这个时候允许a-&gt;b,c-&gt;d并行就有优势了。
         </p>
         <p class="reply-time">
          2019-03-09
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtS26SJpSF7JLu9pusGsy1Qln0NdQg1eV2YKOJxpX2QXaBuuyXMqZY3fm0rhzKwsqN5aa6CVNOQQ/132">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          陈华
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            3
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         对于第三点，按资源顺序来锁就能打破循环等待有疑问。
         <br/>
         例如：账户 1 向 账户 3 转账
         <br/>
         同时 账户 3 向 账户 5 转账
         <br/>
         即使按资源顺序来锁，也是起不了啥作用吧！？，
        </div>
        <span class="time">
         2019-03-14
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          能起作用，这俩操作不会死锁
          <br/>
         </p>
         <p class="reply-time">
          2019-03-14
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/15/fe/f0/135c2cd9.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          λ
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            3
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         单例导致操作也是串行的吧
        </div>
        <span class="time">
         2019-03-11
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          是串行，但是允许A转B，C转D
         </p>
         <p class="reply-time">
          2019-03-11
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/15/fb/f5/6521cb02.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          李可威
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            2
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         老师为什么按序申请资源就可以破坏循环等待条件呢？这点没有看懂求解答
        </div>
        <span class="time">
         2019-03-17
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          循环等待，一定是A-&gt;B-&gt;C-&gt;...-&gt;N-&gt;A形成环状。
          <br/>
          如果按需申请，是不允许N-&gt;A出现的，只能N-&gt;P。没有环状，也就不会死锁了。
         </p>
         <p class="reply-time">
          2019-03-17
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/10/c8/cc/d52d3317.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          GP
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            2
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         问下，上节最后说到，不能用可变对象做锁，这里为何又synchronized（left）？
        </div>
        <span class="time">
         2019-03-13
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          保护的是对象里面的成员，这俩对象变也只能是里面成员变，相对于里面的成员来说，这俩对象是永远不会变的。你可以这样理解。不是绝对不能用于可变对象，只是一条最佳实践。
         </p>
         <p class="reply-time">
          2019-03-13
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/16/01/e7/091804b7.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          长眉_张永
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            2
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         关键是如何找到最合适的锁的力度。
        </div>
        <span class="time">
         2019-03-13
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          是啊，所以知识只是知识，不是能力
         </p>
         <p class="reply-time">
          2019-03-13
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          QQ怪
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            2
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         死循环只是锁的是两个对象，而Account锁的是所有，串行化了
        </div>
        <span class="time">
         2019-03-09
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          死循环里其实也还锁了一个全局对象
         </p>
         <p class="reply-time">
          2019-03-09
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          新世界
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            2
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         没有性能优势，alloctor的操作也是获取alloctor对象的锁，和获取account的对象锁本质没有区别
        </div>
        <span class="time">
         2019-03-09
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          锁的范围变了，所以场景不同性能也会有差异，并发量小的话，性能还会变差
          <br/>
         </p>
         <p class="reply-time">
          2019-03-09
         </p>
        </div>
       </div>
      </li>
      <li class="comment-item" data-v-87ffcada="">
       <img class="avatar" src="picture"/>
       <center>
        <a href="https://static001.geekbang.org/account/avatar/00/0f/48/ee/872ad07e.jpg">
         图片链接
        </a>
       </center>
       <div class="info">
        <div class="hd">
         <span class="username">
          西西弗与卡夫卡
         </span>
         <div class="control">
          <!-- -->
          <a class="btn-praise" href="javascript:;">
           <i class="iconfont">
            
           </i>
           <span>
            2
           </span>
          </a>
         </div>
        </div>
        <div class="bd">
         性能优势还是有的，毕竟后者是对这个类的所有访问都有锁的动作
        </div>
        <span class="time">
         2019-03-09
        </span>
        <div class="reply">
         <div class="reply-hd">
          <i class="iconfont">
           
          </i>
          <span>
           作者回复
          </span>
         </div>
         <p class="reply-content">
          是的，锁的范围是个大问题。允许A-&gt;B 和 C-&gt;D可以并行还是很重要的
         </p>
         <p class="reply-time">
          2019-03-09
         </p>
        </div>
       </div>
      </li>
     </ul>
    </div>
   </div>
  </div>
 </body>
</html>